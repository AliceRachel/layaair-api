<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><meta name="keywords" content="Byte,laya.utils.Byte,BIG_ENDIAN,DATANUM,EMPTY,FPS,I,LITTLE_ENDIAN,_bold,_family,_font,_id,_italic,_size,_useCanvas,args,autoScrollToBottom,buffer,bytesAvailable,caller,canvas,canvasBitmap,canvasNormal,canvasReCache,clientHeight,clientWidth,color,container,context,currFrame,currTimer,currentMemorySize,cursor,datapos,datas,delInterval,delta,document,drawCall,drawTexTm,endian,gMaxV,gMinV,height,hit,hud_height,hud_width,id,inst,length,loopCount,maxCount,method,name,onAndroid,onIE,onIOS,onIPad,onIPhone,onMQQBrowser,onMac,onMobile,onPC,onQQBrowser,onSafari,onWP,onWeiXin,once,onclick,parseXMLFromString,pixelRatio,pos,progress,renderSlow,repeat,scale,scale,scale,shaderCall,spriteCount,spriteRenderUseCacheCount,supportLocalStorage,supportWeakMap,supportWebAudio,total,treeNodeCollision,treeSpriteCollision,trianglesFaces,unHit,update,userAgent,width,window,xdata,ydata,Parse,addDataDef,addData,addLabel,backIn,backInOut,backOut,bind,bounceIn,bounceInOut,bounceOut,callLater,circIn,circInOut,circOut,clear,clear,clear,clear,clear,clear,clearAll,clearAll,clearBySign,clearCache,complete,config,contains,create,createByClass,createByJson,createElement,cubicIn,cubicInOut,cubicOut,customRender,del,destroy,drawHLine,elasticIn,elasticInOut,elasticOut,enable,enable,end,expoIn,expoInOut,expoOut,fitDOMElementInArea,frameLoop,frameOnce,from,from,from,from,get,getClass,getElementById,getGID,getGlobalPosAndScale,getInstance,getItem,getItemByClass,getItemByCreateFun,getPoolBySign,getQueryString,getRegClass,getSystemEndian,getTransformRelativeToWindow,getUTFBytes,getUTFString,gotoLabel,gotoTime,has,hide,hide,linearIn,linearInOut,linearNone,linearOut,loop,measureText,now,now,once,parseInt,pause,pause,pause,play,print,quadIn,quadInOut,quadOut,quartIn,quartInOut,quartOut,quintIn,quintInOut,quintOut,readByte,readFloat32,readFloat32Array,readFloat64,readInt16,readInt16Array,readInt32,readString,readUint16,readUint32,readUint8,readUint8Array,recover,recover,recover,recoverByClass,regClass,regShortClassName,removeElement,removeLabel,reset,restart,resume,resume,resume,run,runCallLater,runTimer,runWith,set,setFont,setStartTime,setTo,show,show,sineIn,sineInOut,sineOut,start,strongIn,strongInOut,strongOut,to,to,to,to,toAngle,toHexColor,toRadian,toString,toggle,updateValue,v2y,writeArrayBuffer,writeByte,writeFloat32,writeFloat64,writeInt16,writeInt32,writeUTFBytes,writeUTFString,writeUint16,writeUint32,writeUint8"><title>laya.utils.Byte</title></head><body><script language="javascript" type="text/javascript" src="../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../help.js"></script><script language="javascript" type="text/javascript" src="../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'Byte - API Documentation';
				var baseRef = '../../';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">API Documentation</td><td class="titleTableTopNav" align="right"><a href="../../package-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../class-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../all-index-A.html" onclick="loadClassListFrame('../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../index.html?laya/utils/Byte.html&amp;laya/utils/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">Byte</td><td class="titleTableSubNav" id="subNav" align="right"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a>&nbsp;| <a href="#constantSummary">Constants</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("Byte"); titleBar_setSubNav(true,true,false,false,false,false,false,false,true,false,false	,false,false,false,false,false);}	
				-->
			</script><div xmlns:fn="http://www.w3.org/2005/xpath-functions" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Package</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">laya.utils</a></td></tr><tr><td class="classHeaderTableLabel">Class</td><td class="classSignature">public  class  Byte</td></tr><tr><td class="classHeaderTableLabel">Inheritance</td><td class="inheritanceList">Byte  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> Object</td></tr></table><p></p><p></p><p></p>
	              <p> 
                  <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
	              <p> 
                  <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
	           <p></p><br/><hr></div><a name="propertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#buffer" class="signatureLink">buffer</a> : ArrayBuffer<div class="summaryTableDescription">[read-only] 
		 获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#bytesAvailable" class="signatureLink">bytesAvailable</a> : int<div class="summaryTableDescription">[read-only] 
		 可从字节流的当前位置到末尾读取的数据的字节数。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#endian" class="signatureLink">endian</a> : String<div class="summaryTableDescription">
		  Byte 实例的字节序。取值为：BIG_ENDIAN 或 BIG_ENDIAN 。
		 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 getSystemEndian 可以获取当前系统的字节序。
		  BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		  LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#length" class="signatureLink">length</a> : int<div class="summaryTableDescription">
		  Byte 对象的长度（以字节为单位）。
		 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。
		 如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#pos" class="signatureLink">pos</a> : int<div class="summaryTableDescription">
		 移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><a name="methodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#Byte()" class="signatureLink">Byte</a>(data:* = null)</div><div class="summaryTableDescription">
		 创建一个 Byte 类的实例。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#clear()" class="signatureLink">clear</a>():void</div><div class="summaryTableDescription">
		 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getSystemEndian()" class="signatureLink">getSystemEndian</a>():String</div><div class="summaryTableDescription">[static] 
		 获取当前主机的字节序。
		 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。
		  BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		 LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUTFBytes()" class="signatureLink">getUTFBytes</a>(len:int = -1):String</div><div class="summaryTableDescription">
		 从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。
		 一般读取的是由 writeUTFBytes 方法写入的字符串。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUTFString()" class="signatureLink">getUTFString</a>():String</div><div class="summaryTableDescription">
		 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。
		 对应的写入方法为： writeUTFString 。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readByte()" class="signatureLink">readByte</a>():int</div><div class="summaryTableDescription">
		 从字节流中读取带符号的字节。
		 返回值的范围是从 -128 到 127。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readFloat32()" class="signatureLink">readFloat32</a>():Number</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readFloat32Array()" class="signatureLink">readFloat32Array</a>(start:int, len:int):*</div><div class="summaryTableDescription">
		 从字节流中 start 参数指定的位置开始，读取 len 参数指定的字节数的数据，用于创建一个 Float32Array 对象并返回此对象。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readFloat64()" class="signatureLink">readFloat64</a>():Number</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readInt16()" class="signatureLink">readInt16</a>():int</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 Int16 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readInt16Array()" class="signatureLink">readInt16Array</a>(start:int, len:int):*</div><div class="summaryTableDescription">
		 从字节流中 start 参数指定的位置开始，读取 len 参数指定的字节数的数据，用于创建一个 Int16Array 对象并返回此对象。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readInt32()" class="signatureLink">readInt32</a>():int</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 Int32 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readString()" class="signatureLink">readString</a>():String</div><div class="summaryTableDescription">
		 常用于解析固定格式的字节流。
		 先从字节流的当前字节偏移位置处读取一个 Uint16 值，然后以此值为长度，读取此长度的字符串。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readUint16()" class="signatureLink">readUint16</a>():uint</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readUint32()" class="signatureLink">readUint32</a>():uint</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readUint8()" class="signatureLink">readUint8</a>():uint</div><div class="summaryTableDescription">
		 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#readUint8Array()" class="signatureLink">readUint8Array</a>(start:int, len:int):<a href="../../Uint8Array.html">Uint8Array</a></div><div class="summaryTableDescription">
		 从字节流中 start 参数指定的位置开始，读取 len 参数指定的字节数的数据，用于创建一个 Uint8Array 对象并返回此对象。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeArrayBuffer()" class="signatureLink">writeArrayBuffer</a>(arraybuffer:*, offset:uint = 0, length:uint = 0):void</div><div class="summaryTableDescription">
		 将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。
		 如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。
		 如果 offset 或 length 小于0，本函数将抛出异常。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeByte()" class="signatureLink">writeByte</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流中写入一个字节。
		 使用参数的低 8 位。忽略高 24 位。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeFloat32()" class="signatureLink">writeFloat32</a>(value:Number):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeFloat64()" class="signatureLink">writeFloat64</a>(value:Number):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeInt16()" class="signatureLink">writeInt16</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeInt32()" class="signatureLink">writeInt32</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint16()" class="signatureLink">writeUint16</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint32()" class="signatureLink">writeUint32</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入 Uint32 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint8()" class="signatureLink">writeUint8</a>(value:int):void</div><div class="summaryTableDescription">
		 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUTFBytes()" class="signatureLink">writeUTFBytes</a>(value:String):void</div><div class="summaryTableDescription">
		 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字为字符串添加前缀。
		 对应的读取方法为： getUTFBytes 。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUTFString()" class="signatureLink">writeUTFString</a>(value:String):void</div><div class="summaryTableDescription">
		 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
		 对应的读取方法为： getUTFString 。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><a name="constantSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Constants</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableConstant"><tr><th>&nbsp;</th><th colspan="2">Constant</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#BIG_ENDIAN" class="signatureLink">BIG_ENDIAN</a> : String = bigEndian<div class="summaryTableDescription">[static] 
		 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 getSystemEndian 可以获取当前系统的字节序。
		  BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		 LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#LITTLE_ENDIAN" class="signatureLink">LITTLE_ENDIAN</a> : String = littleEndian<div class="summaryTableDescription">[static] 
		 主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 getSystemEndian 可以获取当前系统的字节序。
		  LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
		 BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		 </div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><script language="javascript" type="text/javascript"><!--
										showHideInherited();
										--></script><div class="MainContent"><div class="detailSectionHeader">Property Detail</div><a name="propertyDetail"></a><a name="buffer"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">buffer</td><td class="detailHeaderType">property</td></tr></table><div class="detailBody"><code>buffer:ArrayBuffer</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get buffer():ArrayBuffer</code><br/></div><a name="propertyDetail"></a><a name="bytesAvailable"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">bytesAvailable</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>bytesAvailable:int</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 可从字节流的当前位置到末尾读取的数据的字节数。
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get bytesAvailable():int</code><br/></div><a name="propertyDetail"></a><a name="endian"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">endian</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>endian:String</code><p></p><p></p><p>
		 <p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
		 <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
		 <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		  <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get endian():String</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set endian(value:String):void</code><br/></div><a name="propertyDetail"></a><a name="length"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">length</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>length:int</code><p></p><p></p><p>
		 <p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
		 <p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
		 <p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get length():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set length(value:int):void</code><br/></div><a name="propertyDetail"></a><a name="pos"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">pos</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>pos:int</code><p></p><p></p><p>
		 移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
		 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get pos():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set pos(value:int):void</code><br/></div><a name="constructorDetail"></a><div class="detailSectionHeader">Constructor Detail</div><a name="Byte()"></a><a name="Byte(any)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">Byte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Constructor</td></tr></table><div class="detailBody"><code>public function Byte(data:* = null)</code><p></p><p>
		 创建一个 <code>Byte</code> 类的实例。
		 </p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">data</span>:*</code> (default = <code>null</code>)<code></code> &mdash; 用于指定初始化的元素数目，或者用于初始化的TypedArray对象、ArrayBuffer对象。如果为 null ，则预分配一定的内存空间，当可用空间不足时，优先使用这部分内存，如果还不够，则重新分配所需内存。
		 </td></tr></table></div><a name="methodDetail"></a><div class="detailSectionHeader">Method Detail</div><a name="clear()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clear</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td></tr></table><div class="detailBody"><code> public function clear():void</code><p></p><p></p><p>
		 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
		 </p></div><a name="getSystemEndian()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getSystemEndian</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function getSystemEndian():String</code><p></p><p></p><p>
		 <p>获取当前主机的字节序。</p>
		 <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
		 <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		 <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; 当前系统的字节序。
		 </td></tr></table></div><a name="getUTFBytes()"></a><a name="getUTFBytes(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUTFBytes</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUTFBytes(len:int = -1):String</code><p></p><p></p><p>
		 <p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
		 <p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> (default = <code>-1</code>)<code></code> &mdash; 要读的buffer长度，默认将读取缓冲区全部数据。
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; 读取的字符串。
		 </td></tr></table></div><a name="getUTFString()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUTFString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUTFString():String</code><p></p><p></p><p>
		 <p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
		 <p>对应的写入方法为： writeUTFString 。</p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; 读取的字符串。
		 </td></tr></table></div><a name="readByte()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readByte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readByte():int</code><p></p><p></p><p>
		 <p>从字节流中读取带符号的字节。</p>
		 <p>返回值的范围是从 -128 到 127。</p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; 介于 -128 和 127 之间的整数。
		 </td></tr></table></div><a name="readFloat32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readFloat32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readFloat32():Number</code><p></p><p></p><p>
		 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Number</code> &mdash; 单精度（32 位）浮点数。
		 </td></tr></table></div><a name="readFloat32Array()"></a><a name="readFloat32Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readFloat32Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readFloat32Array(start:int, len:int):*</code><p></p><p></p><p>
		 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash; 开始位置。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash; 	需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>*</code> &mdash; 读取的 Float32Array 对象。
		 </td></tr></table></div><a name="readFloat64()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readFloat64</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readFloat64():Number</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Number</code> &mdash; 双精度（64 位）浮点数。
		 </td></tr></table></div><a name="readInt16()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readInt16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readInt16():int</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 Int16 值。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; Int16 值。
		 </td></tr></table></div><a name="readInt16Array()"></a><a name="readInt16Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readInt16Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readInt16Array(start:int, len:int):*</code><p></p><p></p><p>
		 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash; 开始读取的字节偏移量位置。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash; 	需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>*</code> &mdash; 读取的 Uint8Array 对象。
		 </td></tr></table></div><a name="readInt32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readInt32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readInt32():int</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 Int32 值。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; Int32 值。
		 </td></tr></table></div><a name="readString()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readString():String</code><p></p><p></p><p>
		 <p>常用于解析固定格式的字节流。</p>
		 <p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; 读取的字符串。
		 </td></tr></table></div><a name="readUint16()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readUint16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readUint16():uint</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint16 值。
		 </td></tr></table></div><a name="readUint32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readUint32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readUint32():uint</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint32 值。
		 </td></tr></table></div><a name="readUint8()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readUint8</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readUint8():uint</code><p></p><p></p><p>
		 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint8 值。
		 </td></tr></table></div><a name="readUint8Array()"></a><a name="readUint8Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">readUint8Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readUint8Array(start:int, len:int):<a href="../../Uint8Array.html">Uint8Array</a></code><p></p><p></p><p>
		 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash; 开始位置。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash; 	需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Uint8Array.html">Uint8Array</a></code> &mdash; 读取的 Uint8Array 对象。
		 </td></tr></table></div><a name="writeArrayBuffer()"></a><a name="writeArrayBuffer(any,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeArrayBuffer</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeArrayBuffer(arraybuffer:*, offset:uint = 0, length:uint = 0):void</code><p></p><p></p><p>
		 <p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
		 <p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
		 <p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">arraybuffer</span>:*</code> &mdash; 需要写入的 Arraybuffer 对象。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offset</span>:uint</code> (default = <code>0</code>)<code></code> &mdash; 	Arraybuffer 对象的索引的偏移量（以字节为单位）
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">length</span>:uint</code> (default = <code>0</code>)<code></code> &mdash; 	从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
		 </td></tr></table></p></div><a name="writeByte()"></a><a name="writeByte(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeByte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeByte(value:int):void</code><p></p><p></p><p>
		 <p>在字节流中写入一个字节。</p>
		 <p>使用参数的低 8 位。忽略高 24 位。</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code></td></tr></table></p></div><a name="writeFloat32()"></a><a name="writeFloat32(Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeFloat32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeFloat32(value:Number):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:Number</code> &mdash; 单精度（32 位）浮点数。
		 </td></tr></table></p></div><a name="writeFloat64()"></a><a name="writeFloat64(Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeFloat64</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeFloat64(value:Number):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:Number</code> &mdash; 双精度（64 位）浮点数。
		 </td></tr></table></p></div><a name="writeInt16()"></a><a name="writeInt16(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeInt16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeInt16(value:int):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash; 需要写入的 Int16 值。
		 </td></tr></table></p></div><a name="writeInt32()"></a><a name="writeInt32(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeInt32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeInt32(value:int):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash; 需要写入的 Int32 值。
		 </td></tr></table></p></div><a name="writeUint16()"></a><a name="writeUint16(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint16(value:int):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash; 需要写入的Uint16 值。
		 </td></tr></table></p></div><a name="writeUint32()"></a><a name="writeUint32(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint32(value:int):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入 Uint32 值。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash; 需要写入的 Uint32 值。
		 </td></tr></table></p></div><a name="writeUint8()"></a><a name="writeUint8(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint8</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint8(value:int):void</code><p></p><p></p><p>
		 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash; 需要写入的 Uint8 值。
		 </td></tr></table></p></div><a name="writeUTFBytes()"></a><a name="writeUTFBytes(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUTFBytes</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUTFBytes(value:String):void</code><p></p><p></p><p>
		 <p>将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字为字符串添加前缀。</p>
		 <p>对应的读取方法为： getUTFBytes 。</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:String</code> &mdash; 要写入的字符串。
		 </td></tr></table></p></div><a name="writeUTFString()"></a><a name="writeUTFString(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUTFString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUTFString(value:String):void</code><p></p><p></p><p>
		 <p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
		 <p>对应的读取方法为： getUTFString 。</p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:String</code> &mdash; 要写入的字符串值。
		 </td></tr></table></p></div><div class="detailSectionHeader">Constant Detail</div><a name="constantDetail"></a><a name="BIG_ENDIAN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">BIG_ENDIAN</td><td class="detailHeaderType">Constant</td></tr></table><div class="detailBody"><code>public static const BIG_ENDIAN:String = bigEndian</code><p></p><p></p><p>
		 <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
		 <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。
		 <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		 </p></div><a name="constantDetail"></a><a name="LITTLE_ENDIAN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">LITTLE_ENDIAN</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public static const LITTLE_ENDIAN:String = littleEndian</code><p></p><p></p><p>
		 <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
		 <p> <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。
		 <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>
		 </p></div><br/><br/><hr><br/><p></p><center class="copyright"><footer></footer><br/>Sat Oct 13 2018, 02:18 PM +08:00  </center></div></body></html><!--<br/>Sat Oct 13 2018, 02:18 PM +08:00  -->