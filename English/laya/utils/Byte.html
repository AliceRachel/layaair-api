<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- saved from url=(0014)about:internet --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><meta name="keywords" content="Byte,laya.utils.Byte,BIG_ENDIAN,FPS,I,LITTLE_ENDIAN,_classMap,_useCanvas,args,buffer,bytesAvailable,caller,canvas,canvasBitmap,canvasNormal,canvasReCache,clientHeight,clientWidth,container,context,currFrame,currTimer,currentMemorySize,cursor,delInterval,delta,document,drawCall,endian,getClass,height,hit,httpProtocol,keys,length,loopCount,maxCount,method,onAndroid,onEdge,onFirefox,onIE,onIOS,onIPad,onIPhone,onMQQBrowser,onMac,onMobile,onPC,onQQBrowser,onSafari,onWP,onWeiXin,once,onclick,parseXMLFromString,pixelRatio,pos,progress,renderSlow,scale,scale,shaderCall,spriteCount,spriteRenderUseCacheCount,supportWeakMap,total,treeNodeCollision,treeSpriteCollision,trianglesFaces,unHit,update,userAgent,values,width,window,addGraphicToSprite,addGraphicsToSprite,addLabel,backIn,backInOut,backOut,bind,bounceIn,bounceInOut,bounceOut,callLater,circIn,circInOut,circOut,clear,clear,clear,clear,clear,clear,clear,clearAll,clearAll,clearBySign,clearCache,complete,contains,create,createByJson,createElement,cubicIn,cubicInOut,cubicOut,del,destroy,elasticIn,elasticInOut,elasticOut,enable,enable,ensureWrite,expoIn,expoInOut,expoOut,fitDOMElementInArea,frameLoop,frameOnce,from,from,from,from,get,get,getByte,getElementById,getFloat32,getFloat32Array,getFloat64,getGID,getGlobalPosAndScale,getInstance,getInt16,getInt16Array,getInt32,getItem,getItemByClass,getItemByCreateFun,getPoolBySign,getRegClass,getString,getSystemEndian,getTransformRelativeToWindow,getUTFBytes,getUTFString,getUint16,getUint32,getUint8,getUint8Array,gotoLabel,gotoTime,has,hide,hide,indexOf,isHit,linearIn,linearInOut,linearNone,linearOut,loop,measureText,now,once,parseInt,pause,pause,play,print,quadIn,quadInOut,quadOut,quartIn,quartInOut,quartOut,quintIn,quintInOut,quintOut,recover,recover,recover,regClass,remove,removeElement,removeLabel,reset,restart,resume,resume,run,runCallLater,runTimer,runWith,set,set,setStartTime,setTo,show,show,sineIn,sineInOut,sineOut,strongIn,strongInOut,strongOut,to,to,to,to,toAngle,toHexColor,toRadian,toString,toggle,writeArrayBuffer,writeByte,writeFloat32,writeFloat64,writeInt16,writeInt32,writeUTFBytes,writeUTFString,writeUint16,writeUint32,writeUint8"><title>laya.utils.Byte</title></head><body><script language="javascript" type="text/javascript" src="../../asdoc.js"></script><script language="javascript" type="text/javascript" src="../../help.js"></script><script language="javascript" type="text/javascript" src="../../cookies.js"></script><script language="javascript" type="text/javascript"><!--
				asdocTitle = 'Byte - API Documentation';
				var baseRef = '../../';
				window.onload = configPage;
			--></script>
<script type="text/javascript">
			scrollToNameAnchor();
		</script><table class="titleTable" cellpadding="0" cellspacing="0" id="titleTable" style="display:none"><tr><td class="titleTableTitle" align="left">API Documentation</td><td class="titleTableTopNav" align="right"><a href="../../package-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Packages</a>&nbsp;|&nbsp;<a href="../../class-summary.html" onclick="loadClassListFrame('../../all-classes.html')">All Classes</a>&nbsp;|&nbsp;<a href="../../all-index-A.html" onclick="loadClassListFrame('../../index-list.html')">Index</a>&nbsp;|&nbsp;<a id="framesLink1" href="../../index.html?laya/utils/Byte.html&amp;laya/utils/class-list.html">Frames</a><a id="noFramesLink1" style="display:none" href="" onclick="parent.location=document.location"> No Frames </a></td><td class="titleTableLogo" align="right" rowspan="3"><img src="../../images/logo.jpg" class="logoImage" alt=" Adobe Logo " title=" Adobe Logo "></td></tr><tr class="titleTableRow2"><td class="titleTableSubTitle" id="subTitle" align="left">Byte</td><td class="titleTableSubNav" id="subNav" align="right"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a>&nbsp;| <a href="#constantSummary">Constants</a></td></tr><tr class="titleTableRow3"><td colspan="3">&nbsp;</td></tr></table><script language="javascript" type="text/javascript" xml:space="preserve">
				<!--
				
					if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("Byte"); titleBar_setSubNav(true,true,false,false,false,false,false,false,true,false,false	,false,false,false,false,false);}	
				-->
			</script><div xmlns:fn="http://www.w3.org/2005/xpath-functions" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Package</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">laya.utils</a></td></tr><tr><td class="classHeaderTableLabel">Class</td><td class="classSignature">public  class  Byte</td></tr><tr><td class="classHeaderTableLabel">Inheritance</td><td class="inheritanceList">Byte  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> Object</td></tr></table><p></p><p></p><p></p>
	              <p> 
                  <code>Byte</code> Class provides methods and properties for optimizing reading, writing, and processing binary data. </p>
	              <p>
                  <b> Be carefulï¼š </b> 
                  <code>Byte</code> Class applies to high-level developers who need access to data at the byte level. </p>
	           <p></p><br/><hr></div><a name="propertySummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Properties</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Property</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#buffer" class="signatureLink">buffer</a> : ArrayBuffer<div class="summaryTableDescription">[read-only] 
		 Gets the ArrayBuffer data of this object, and the data contains only the valid data part.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#bytesAvailable" class="signatureLink">bytesAvailable</a> : int<div class="summaryTableDescription">[read-only] 
		 The number of bytes that can be read from the current location of the byte stream to the end of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#endian" class="signatureLink">endian</a> : String<div class="summaryTableDescription">
		  Byte The byte order of the instance.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#length" class="signatureLink">length</a> : int<div class="summaryTableDescription">
		  Byte The length of an object (in bytes).</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#pos" class="signatureLink">pos</a> : int<div class="summaryTableDescription">
		 Move or return  Byte  The current position (in bytes) of the read and write pointer of the object.</div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><a name="methodSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Methods </div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Method</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#Byte()" class="signatureLink">Byte</a>(data:* = null)</div><div class="summaryTableDescription">
		 Create a Byte An example of a class.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#clear()" class="signatureLink">clear</a>():void</div><div class="summaryTableDescription">
		 Clears the contents of the byte array and resets the length and POS properties to 0.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#ensureWrite()" class="signatureLink">ensureWrite</a>(lengthToEnsure:int):void</div><div class="summaryTableDescription">
		  Ensure that the available length of this byte stream is not less than less than lengthToEnsure The value specified by the parameter.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getByte()" class="signatureLink">getByte</a>():int</div><div class="summaryTableDescription">
		  Read the bytes with symbols from the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getFloat32()" class="signatureLink">getFloat32</a>():Number</div><div class="summaryTableDescription">
		 A IEEE 754 single precision (32 bit) floating point number is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getFloat32Array()" class="signatureLink">getFloat32Array</a>(start:int, len:int):*</div><div class="summaryTableDescription">
		 From the byte stream start The location of the parameter specified, read len The number of bytes specified by the parameter to create a Float32Array Object and return to this object.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getFloat64()" class="signatureLink">getFloat64</a>():Number</div><div class="summaryTableDescription">
		 A IEEE 754 double precision (64 bit) floating point number is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getInt16()" class="signatureLink">getInt16</a>():int</div><div class="summaryTableDescription">
		 A Int16 value is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getInt16Array()" class="signatureLink">getInt16Array</a>(start:int, len:int):*</div><div class="summaryTableDescription">
		 From the byte stream start The location of the parameter specified, read len The number of bytes specified by the parameter to create a Int16Array Object and return to this object.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getInt32()" class="signatureLink">getInt32</a>():int</div><div class="summaryTableDescription">
		 A Int32 value is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getString()" class="signatureLink">getString</a>():String</div><div class="summaryTableDescription">
		  It is often used to parse the byte stream in a fixed format.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getSystemEndian()" class="signatureLink">getSystemEndian</a>():String</div><div class="summaryTableDescription">[static] 
		  Gets the byte order of the current host.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUint16()" class="signatureLink">getUint16</a>():uint</div><div class="summaryTableDescription">
		 A Uint16 value is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUint32()" class="signatureLink">getUint32</a>():uint</div><div class="summaryTableDescription">
		 A Uint32 value is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUint8()" class="signatureLink">getUint8</a>():uint</div><div class="summaryTableDescription">
		 A Uint8 value is read from the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUint8Array()" class="signatureLink">getUint8Array</a>(start:int, len:int):Uint8Array</div><div class="summaryTableDescription">
		 From the byte stream start The location of the parameter specified, read len The number of bytes specified by the parameter to create a Uint8Array Object and return to this object.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUTFBytes()" class="signatureLink">getUTFBytes</a>(len:int = -1):String</div><div class="summaryTableDescription">
		  Reads a UTF-8 byte sequence specified by the length parameter from the byte stream and returns a string.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#getUTFString()" class="signatureLink">getUTFString</a>():String</div><div class="summaryTableDescription">
		  Read a UTF-8 string from the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeArrayBuffer()" class="signatureLink">writeArrayBuffer</a>(arraybuffer:*, offset:uint = 0, length:uint = 0):void</div><div class="summaryTableDescription">
		  Writes byte sequences with offset as the initial offset and length length as the byte stream in the specified arraybuffer object.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeByte()" class="signatureLink">writeByte</a>(value:int):void</div><div class="summaryTableDescription">
		  Write a byte in the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeFloat32()" class="signatureLink">writeFloat32</a>(value:Number):void</div><div class="summaryTableDescription">
		 A IEEE 754 single precision (32 bit) floating point number is written at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeFloat64()" class="signatureLink">writeFloat64</a>(value:Number):void</div><div class="summaryTableDescription">
		 A IEEE 754 double precision (64 bit) floating point number is written at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeInt16()" class="signatureLink">writeInt16</a>(value:int):void</div><div class="summaryTableDescription">
		 Writes the specified Int16 value at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeInt32()" class="signatureLink">writeInt32</a>(value:int):void</div><div class="summaryTableDescription">
		 Writes the specified Int32 value at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint16()" class="signatureLink">writeUint16</a>(value:int):void</div><div class="summaryTableDescription">
		 Writes the specified Uint16 value at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint32()" class="signatureLink">writeUint32</a>(value:int):void</div><div class="summaryTableDescription">
		 Writes the Uint32 value at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUint8()" class="signatureLink">writeUint8</a>(value:int):void</div><div class="summaryTableDescription">
		 Writes the specified Uint8 value at the current byte offset position of the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUTFBytes()" class="signatureLink">writeUTFBytes</a>(value:String):void</div><div class="summaryTableDescription">
		  Writes the UTF-8 string to the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="#writeUTFString()" class="signatureLink">writeUTFString</a>(value:String):void</div><div class="summaryTableDescription">
		  Writes the UTF-8 string to the byte stream.</div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><a name="constantSummary"></a><div class="summarySection"><div class="summaryTableTitle">Public Constants</div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableConstant"><tr><th>&nbsp;</th><th colspan="2">Constant</th><th class="summaryTableOwnerCol">Defined By</th></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#BIG_ENDIAN" class="signatureLink">BIG_ENDIAN</a> : String = bigEndian<div class="summaryTableDescription">[static] 
		  Host byte order is the two different order for CPU to store data, including small end byte order and large byte order.</div></td><td class="summaryTableOwnerCol">Byte</td></tr><tr class=""><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="#LITTLE_ENDIAN" class="signatureLink">LITTLE_ENDIAN</a> : String = littleEndian<div class="summaryTableDescription">[static] 
		  Host byte order is the two different order for CPU to store data, including small end byte order and large byte order.</div></td><td class="summaryTableOwnerCol">Byte</td></tr></table></div><script language="javascript" type="text/javascript"><!--
										showHideInherited();
										--></script><div class="MainContent"><div class="detailSectionHeader">Property Detail</div><a name="propertyDetail"></a><a name="buffer"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">buffer</td><td class="detailHeaderType">property</td></tr></table><div class="detailBody"><code>buffer:ArrayBuffer</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 Gets the ArrayBuffer data of this object, and the data contains only the valid data part. 
		 	 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get buffer():ArrayBuffer</code><br/></div><a name="propertyDetail"></a><a name="bytesAvailable"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">bytesAvailable</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>bytesAvailable:int</code>&nbsp;&nbsp;[read-only] <p></p><p></p><p>
		 The number of bytes that can be read from the current location of the byte stream to the end of the byte stream. 
		 	 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get bytesAvailable():int</code><br/></div><a name="propertyDetail"></a><a name="endian"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">endian</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>endian:String</code><p></p><p></p><p>
		 <p> <code>Byte</code> The byte order of the instance. The value is as follows: <code>BIG_ENDIAN</code> or <code>BIG_ENDIAN</code> . </p>
		 <p> Host byte order is the two different order for CPU to store data, including small end byte order and large byte order. adopt <code>getSystemEndian</code> You can get the byte order of the current system. </p>
		 <p> <code>BIG_ENDIAN</code> : large byte order, address low storage value high, address high storage value low. Sometimes it's called the network byte order.
		  <code>LITTLE_ENDIAN</code></p>
		 	 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get endian():String</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set endian(value:String):void</code><br/></div><a name="propertyDetail"></a><a name="length"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">length</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>length:int</code><p></p><p></p><p>
		 <p> <code>Byte</code> The length of an object (in bytes). </p>
		 <p> If the length is set to a value larger than the current length, the right of the byte array is filled with zero; if the length is set to a value less than the current length, the array of bytes will be truncated. </p>
		 <p> If the length of the set is greater than the byte length of the current allocated memory space, the memory space is reassigned, the size of which is larger than the 2 times the length, the current allocated length, and the original data to the new memory space; if the length is less than the current assigned. The byte length of the memory space also redistributes the memory space, the size is set to set the length, and the original data is truncated from the length to the new memory space. </p>
		 	 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get length():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set length(value:int):void</code><br/></div><a name="propertyDetail"></a><a name="pos"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">pos</td><td class="detailHeaderType">property</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>pos:int</code><p></p><p></p><p>
		 Move or return  Byte  The current position (in bytes) of the read and write pointer of the object. The next time you call the read method, you will start reading at this location, or you will start writing at this location when the next call is written. 
		 	 </p><br/><span class="label"> Implementation </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get pos():int</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set pos(value:int):void</code><br/></div><a name="constructorDetail"></a><div class="detailSectionHeader">Constructor Detail</div><a name="Byte()"></a><a name="Byte(any)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">Byte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Constructor</td></tr></table><div class="detailBody"><code>public function Byte(data:* = null)</code><p></p><p>
		 Create a <code>Byte</code> An example of a class. 
		 </p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">data</span>:*</code> (default = <code>null</code>)<code></code> &mdash;  Used to specify the number of initialized elements, or for initialized TypedArray objects and ArrayBuffer objects. If it is null, a certain memory space is pre allocated. When the available space is insufficient, this part of memory is used first, and if it is not enough, the required memory is reassigned. 
		 	 </td></tr></table></div><a name="methodDetail"></a><div class="detailSectionHeader">Method Detail</div><a name="clear()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">clear</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td></tr></table><div class="detailBody"><code> public function clear():void</code><p></p><p></p><p>
		 Clears the contents of the byte array and resets the length and POS properties to 0. Calling this method will release  Byte  The memory occupied by the instance. 
		 	 </p></div><a name="ensureWrite()"></a><a name="ensureWrite(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">ensureWrite</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function ensureWrite(lengthToEnsure:int):void</code><p></p><p></p><p>
		 <p> Ensure that the available length of this byte stream is not less than less than <code>lengthToEnsure</code> The value specified by the parameter. </p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">lengthToEnsure</span>:int</code> &mdash;  The specified length. 
		 	 </td></tr></table></p></div><a name="getByte()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getByte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getByte():int</code><p></p><p></p><p>
		 <p> Read the bytes with symbols from the byte stream. </p>
		 <p> The range of return values is from -128 to 127. </p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; An integer between -128 and 127. 
		 	 </td></tr></table></div><a name="getFloat32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getFloat32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getFloat32():Number</code><p></p><p></p><p>
		 A IEEE 754 single precision (32 bit) floating point number is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Number</code> &mdash; A single precision (32 bit) floating-point number. 
		 	 </td></tr></table></div><a name="getFloat32Array()"></a><a name="getFloat32Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getFloat32Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getFloat32Array(start:int, len:int):*</code><p></p><p></p><p>
		 From the byte stream <code>start</code> The location of the parameter specified, read <code>len</code> The number of bytes specified by the parameter to create a <code>Float32Array</code> Object and return to this object. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash;  Start the position. 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash;  The length of the byte that needs to be read. If the length to be read exceeds the readable range, only the values in the readable range are returned. 
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>*</code> &mdash; The Float32Array object that is read. 
		 	 </td></tr></table></div><a name="getFloat64()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getFloat64</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getFloat64():Number</code><p></p><p></p><p>
		 A IEEE 754 double precision (64 bit) floating point number is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Number</code> &mdash; A double - precision (64 - bit) floating point number. 
		 	 </td></tr></table></div><a name="getInt16()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getInt16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getInt16():int</code><p></p><p></p><p>
		 A Int16 value is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; Int16 value. 
		 	 </td></tr></table></div><a name="getInt16Array()"></a><a name="getInt16Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getInt16Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getInt16Array(start:int, len:int):*</code><p></p><p></p><p>
		 From the byte stream <code>start</code> The location of the parameter specified, read <code>len</code> The number of bytes specified by the parameter to create a <code>Int16Array</code> Object and return to this object. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash;  The location of the byte offset that begins to read. 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash;  The length of the byte that needs to be read. If the length to be read exceeds the readable range, only the values in the readable range are returned. 
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>*</code> &mdash; The Uint8Array object that is read. 
		 	 </td></tr></table></div><a name="getInt32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getInt32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getInt32():int</code><p></p><p></p><p>
		 A Int32 value is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>int</code> &mdash; Int32 value. 
		 	 </td></tr></table></div><a name="getString()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getString():String</code><p></p><p></p><p>
		 <p> It is often used to parse the byte stream in a fixed format. </p>
		 <p> First read one from the current byte offset position of the byte stream. <code>Uint16</code> Value, and then read the string of this length with this value as length. </p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; The read string. 
		 	 </td></tr></table></div><a name="getSystemEndian()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getSystemEndian</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public static function getSystemEndian():String</code><p></p><p></p><p>
		 <p> Gets the byte order of the current host. </p>
		 <p> Host byte order is the two different order for CPU to store data, including small end byte order and large byte order. </p>
		 <p> <code>BIG_ENDIAN</code> : large byte order, address low storage value high, address high storage value low. Sometimes it's called the network byte order.
		  <code>LITTLE_ENDIAN</code></p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; The byte order of the current system. 
		 	 </td></tr></table></div><a name="getUint16()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUint16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUint16():uint</code><p></p><p></p><p>
		 A Uint16 value is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint16 value. 
		 	 </td></tr></table></div><a name="getUint32()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUint32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUint32():uint</code><p></p><p></p><p>
		 A Uint32 value is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint32 value. 
		 	 </td></tr></table></div><a name="getUint8()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUint8</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUint8():uint</code><p></p><p></p><p>
		 A Uint8 value is read from the current byte offset position of the byte stream. 
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>uint</code> &mdash; Uint8 value. 
		 	 </td></tr></table></div><a name="getUint8Array()"></a><a name="getUint8Array(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUint8Array</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUint8Array(start:int, len:int):Uint8Array</code><p></p><p></p><p>
		 From the byte stream <code>start</code> The location of the parameter specified, read <code>len</code> The number of bytes specified by the parameter to create a <code>Uint8Array</code> Object and return to this object. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">start</span>:int</code> &mdash;  Start the position. 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> &mdash;  The length of the byte that needs to be read. If the length to be read exceeds the readable range, only the values in the readable range are returned. 
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>Uint8Array</code> &mdash; The Uint8Array object that is read. 
		 	 </td></tr></table></div><a name="getUTFBytes()"></a><a name="getUTFBytes(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUTFBytes</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUTFBytes(len:int = -1):String</code><p></p><p></p><p>
		 <p> Reads a UTF-8 byte sequence specified by the length parameter from the byte stream and returns a string. </p>
		 <p> Generally read string is written by writeUTFBytes method. </p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">len</span>:int</code> (default = <code>-1</code>)<code></code> &mdash;  The length of buffer to read will read all the data in the buffer by default. 
		 </td></tr></table></p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; The read string. 
		 	 </td></tr></table></div><a name="getUTFString()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">getUTFString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getUTFString():String</code><p></p><p></p><p>
		 <p> Read a UTF-8 string from the byte stream. Assume that the prefix of a string is an unsigned short integer, which represents the length to be read. </p>
		 <p> The corresponding writing method is: writeUTFString. </p>
		 </p><p></p><span class="label">Returns</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code>String</code> &mdash; The read string. 
		 	 </td></tr></table></div><a name="writeArrayBuffer()"></a><a name="writeArrayBuffer(any,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeArrayBuffer</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeArrayBuffer(arraybuffer:*, offset:uint = 0, length:uint = 0):void</code><p></p><p></p><p>
		 <p> Writes byte sequences with offset as the initial offset and length length as the byte stream in the specified arraybuffer object. </p>
		 <p> If the length parameter is omitted, the default length is 0, which will start from offset to the entire buffer; if the offset parameter is omitted, the entire buffer is written. </p>
		 <p> If offset or length is less than 0, this function throws an exception. </p>
		 $NEXTBIG has not been able to judge the legitimacy of length and arraybuffer, and when the developer fills in the wrong length value, it will result in writing redundant blank data or even memory overflow. In order to avoid the function that the developer is using this method, the next major version will fix the problem. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">arraybuffer</span>:*</code> &mdash;  The Arraybuffer object that needs to be written. 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offset</span>:uint</code> (default = <code>0</code>)<code></code> &mdash;  The offset of the index of the Arraybuffer object (in bytes). 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">length</span>:uint</code> (default = <code>0</code>)<code></code> &mdash;  Write to the Arraybuffer object  Byte  The length of an object (in bytes) 
		 	 </td></tr></table></p></div><a name="writeByte()"></a><a name="writeByte(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeByte</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeByte(value:int):void</code><p></p><p></p><p>
		 <p> Write a byte in the byte stream. </p>
		 <p> The low 8 bits of the parameters are used. Ignore the high 24 bits. </p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code></td></tr></table></p></div><a name="writeFloat32()"></a><a name="writeFloat32(Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeFloat32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeFloat32(value:Number):void</code><p></p><p></p><p>
		 A IEEE 754 single precision (32 bit) floating point number is written at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:Number</code> &mdash;  A single precision (32 bit) floating-point number. 
		 	 </td></tr></table></p></div><a name="writeFloat64()"></a><a name="writeFloat64(Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeFloat64</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeFloat64(value:Number):void</code><p></p><p></p><p>
		 A IEEE 754 double precision (64 bit) floating point number is written at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:Number</code> &mdash;  A double - precision (64 - bit) floating point number. 
		 	 </td></tr></table></p></div><a name="writeInt16()"></a><a name="writeInt16(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeInt16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeInt16(value:int):void</code><p></p><p></p><p>
		 Writes the specified Int16 value at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash;  The Int16 value that needs to be written. 
		 	 </td></tr></table></p></div><a name="writeInt32()"></a><a name="writeInt32(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeInt32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeInt32(value:int):void</code><p></p><p></p><p>
		 Writes the specified Int32 value at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash;  The Int32 value that needs to be written. 
		 	 </td></tr></table></p></div><a name="writeUint16()"></a><a name="writeUint16(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint16</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint16(value:int):void</code><p></p><p></p><p>
		 Writes the specified Uint16 value at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash;  The Uint16 value that needs to be written. 
		 	 </td></tr></table></p></div><a name="writeUint32()"></a><a name="writeUint32(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint32</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint32(value:int):void</code><p></p><p></p><p>
		 Writes the Uint32 value at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash;  The Uint32 value that needs to be written. 
		 	 </td></tr></table></p></div><a name="writeUint8()"></a><a name="writeUint8(int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUint8</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUint8(value:int):void</code><p></p><p></p><p>
		 Writes the specified Uint8 value at the current byte offset position of the byte stream. 
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:int</code> &mdash;  The Uint8 value that needs to be written. 
		 	 </td></tr></table></p></div><a name="writeUTFBytes()"></a><a name="writeUTFBytes(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUTFBytes</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUTFBytes(value:String):void</code><p></p><p></p><p>
		 <p> Writes the UTF-8 string to the byte stream. Similar to the writeUTF () method, but writeUTFBytes () does not use the 16 bit length word to add a prefix to the string. </p>
		 <p> The corresponding reading method is: getUTFBytes. </p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:String</code> &mdash;  The string to be written. 
		 	 </td></tr></table></p></div><a name="writeUTFString()"></a><a name="writeUTFString(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">writeUTFString</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function writeUTFString(value:String):void</code><p></p><p></p><p>
		 <p> Writes the UTF-8 string to the byte stream. First write the length of the UTF-8 string represented in bytes (as a 16 bit integer) and then write to the byte representing the string character. </p>
		 <p> The corresponding reading method is: getUTFString. </p>
		 </p><p><span class="label"> Parameters </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">value</span>:String</code> &mdash;  The string value to be written. 
		 	 </td></tr></table></p></div><div class="detailSectionHeader">Constant Detail</div><a name="constantDetail"></a><a name="BIG_ENDIAN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">BIG_ENDIAN</td><td class="detailHeaderType">Constant</td></tr></table><div class="detailBody"><code>public static const BIG_ENDIAN:String = bigEndian</code><p></p><p></p><p>
		 <p> Host byte order is the two different order for CPU to store data, including small end byte order and large byte order. adopt <code>getSystemEndian</code> You can get the byte order of the current system. </p>
		 <p> <code>BIG_ENDIAN</code> : large byte order, address low storage value high, address high storage value low. Sometimes it's called the network byte order. 
		  <code>LITTLE_ENDIAN</code></p>
		 	 </p></div><a name="constantDetail"></a><a name="LITTLE_ENDIAN"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">LITTLE_ENDIAN</td><td class="detailHeaderType">Constant</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>public static const LITTLE_ENDIAN:String = littleEndian</code><p></p><p></p><p>
		 <p> Host byte order is the two different order for CPU to store data, including small end byte order and large byte order. adopt <code>getSystemEndian</code> You can get the byte order of the current system. </p>
		 <p> <code>LITTLE_ENDIAN</code> Small end byte order, low address low storage value, high address storage value. 
		  <code>BIG_ENDIAN</code></p>
		 	 </p></div><br/><br/><hr><br/><p></p><center class="copyright"><footer></footer><br/>Mon Jun 11 2018, 05:10 PM +08:00  </center></div></body></html><!--<br/>Mon Jun 11 2018, 05:10 PM +08:00  -->